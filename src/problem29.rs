/// Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
/// 22=4, 23=8, 24=16, 25=32
/// 32=9, 33=27, 34=81, 35=243
/// 42=16, 43=64, 44=256, 45=1024
/// 52=25, 53=125, 54=625, 55=3125
/// If they are then placed in numerical order, with any repeats removed,
/// we get the following sequence of 15 distinct terms:
/// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
/// How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
use num::integer::lcm;
use std::collections::HashSet;

pub fn main() -> i32 {
    let mut res = 99 * 99;
    for i in [2, 3, 5, 6, 7, 10] {
        let mut exp = 2;
        while (i as i32).pow(exp) <= 100 {
            res -= get_num_dups(exp as i32);
            exp += 1;
        }
    }
    res
}

fn get_num_dups(exp: i32) -> i32 {
    let mut h: HashSet<i32> = HashSet::from_iter((2..=100).collect::<Vec<i32>>());
    for n in 1..exp {
        let l = lcm(n, exp);
        let step = l / exp;
        let lim = (step * 100) / (l / n);
        for a in (step..=lim).step_by(step as usize) {
            h.remove(&(a as i32));
        }
    }
    99 - h.len() as i32
}

#[test]
fn test() {
    assert_eq!(get_num_dups(2, 3), 49);
    assert_eq!(get_num_dups(2, 5), 48);
    assert_eq!(get_num_dups(3, 3), 49);
}
